\chapter{Implementación}

La implementación del software se ha dividido en hitos. Cada hito representa cada producto mínimamente viable que se publicará.
Los \href{https://github.com/RubenDelgadoPareja/TFG-Triage-Inteligente-Consulta-Medica/milestones}{hitos} han sido definidos en GitHub y
cada uno de ellos contiene un grupo de \href{https://github.com/RubenDelgadoPareja/TFG-Triage-Inteligente-Consulta-Medica/issues}{\textit{issues}} que se corresponden
con las distintas mejoras que se han ido incorporando al software a lo largo de su desarrollo.

A lo largo de este capítulo se pretende reflejar las herramientas usadas durante todo el proceso de desarrollo y
se argumentará por qué se han tomado estas decisiones, al igual que en el capítulo Metodología{\ref{ch:metodologia}} explicamos
la planificación y forma de trabajo.

\section{Hito 0: Montar repositorio inicial}\ref{sb:hito0}

\subsection{Entorno de Desarrollo Integrado}
He decidido elegir Visual Studio Code para el desarrollo del proyecto debido a que tengo experiencia utilizándola y me siento cómodo desarrollando en este {\textit{IDE}}.
Otro motivo fundamental es que es gratuita, además contiene una gran cantidad de extensiones y configuraciones lo que facilita programar, también es ligero y multiplataforma.
Me parece muy cómodo y versátil frente a otras opciones.

\subsection{Herramientas de documentación}

\paragraph*{Compilación de LaTeX}
La memoria se ha escrito empleando el lenguaje LaTeX, que es un sistema de composición de documentos bastante empleado
en el ámbito académico y científico, es necesario para poder generar la documentación final, agrupando cada capítulo, sección y
gráfica. Para generar este archivo final debemos ejecutar el comando \textit{all} del Makefile

\paragraph*{Corrector ortográfico gramatical}
Para comprobar activamente que lo escrito en la memoria esté correcto se ha empleado una herramienta de LaTeX llamada \href{https://github.com/sylvainhalle/textidote}{TeXtidote}.
Esta herramienta nos permite corregir la ortografía, gramática y semántica de la documentación escrita. Se puede ejecutar la corrección a través del comando \textit{check} del Makefile,
generando un borrador con la documentación marcando los errores y posibles cambios. Además, se ha añadido este comando a los hooks de GitHub para ejecutarlo antes de cada commit.

\subsection{Código}

\subsubsection*{Integración Continua}
La integración continua es una práctica de desarrollo de software que tiene como objetivo principal mejorar la calidad del código, aumentar la eficiencia y agilizar el proceso de entrega de software.
Las diferentes opciones que encontramos para el cliente o local pueden ser git, SVN, Mercurial y para el servidor donde se harán las pruebas y la integración se presentan las siguientes
alternativas Jenkins, Travis, Circle, GitHub Actions. He decido escoger git para el cliente y GitHub Actions para el servidor porque me resultan fáciles de configurar y escalabilidad.
Gracias a esta metodología podemos automatizar la ejecución de test, linter y corrector ortográfico, de esta manera comprobaremos antes de ciertas acciones con los hooks de GitHub que todo está
correctamente. También se había barajado la opción de utilizar un paquete llamado \textit{husky} para Node.js, pero no se ha escogido finalmente para aprender nuevas tecnologías.


\subsubsection*{Lenguaje de Programación}
Para el desarrollo de un proyecto es esencial decidir con qué herramienta principal, en este caso el lenguaje se va a crear. De entre mi pila de lenguajes de programación he
escogido Typescript junto con Node.js, ya que, estoy trabajando con él. Creo que da una gran robustez gracias al tipado y apoya mucho al Diseño Dirigido al Dominio, no como otros lenguajes como Java o Ruby
Cuenta con una gran batería de librerías que agiliza el desarrollo y permite la implementación rápida de características.


\subsubsection*{Análisis estático}
Es necesario tener un constante análisis estático para mantener un código limpio, coherente y libre de errores, de esta forma garantizar la calidad, la eficiencia y sostenibilidad a largo
del tiempo. Se ha decidido elegir ESLint con Typescript, ya que es un \textit{linter} que se emplea para el lenguaje de JavaScript, pero se puede aprovechar con TypeScript.
ESLint te permite aplicar reglas personalizadas, reglas predefinidas y configuraciones de estilo para garantizar que tu código sea consistente y libre de problemas.
No se ha escogido TSLint, por el hecho de que, está obsoleta y no tiene mantenimiento, también se ha barajado SonarQube y CodeClimate.

\subsubsection*{Test unitarios e integración}
