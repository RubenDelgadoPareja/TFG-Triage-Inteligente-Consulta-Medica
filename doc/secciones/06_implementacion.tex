\chapter{Implementación}

La implementación del software se ha dividido en hitos. Cada hito representa cada producto mínimamente viable que se publicará.
Los \href{https://github.com/RubenDelgadoPareja/TFG-Triage-Inteligente-Consulta-Medica/milestones}{hitos} han sido definidos en GitHub y
cada uno de ellos contiene un grupo de \href{https://github.com/RubenDelgadoPareja/TFG-Triage-Inteligente-Consulta-Medica/issues}{\textit{issues}} que se corresponden
con las distintas mejoras que se han ido incorporando al software a lo largo de su desarrollo.

A lo largo de este capítulo se pretende reflejar las herramientas usadas durante todo el proceso de desarrollo y
se argumentará por qué se han tomado estas decisiones, al igual que en el capítulo Metodología\ref{ch:metodologia} explicamos
la planificación y forma de trabajo.

\section{Hito 0: Montar repositorio inicial}\ref{sb:hito0}

\subsection{Entorno de Desarrollo Integrado}
He decidido elegir Visual Studio Code para el desarrollo del proyecto debido a una serie de ventajas. La principal ventaja
es que tengo una gran experiencia utilizándola y me siento cómodo desarrollando. Además, tiene una amplia comunidad y
extensiones que mejoran la experiencia de desarrollo y permite adaptar el IDE al proyecto, también es gratuita frente
a otras opciones, es ligero, multiplataforma y muy personalizable.

\subsection{Herramientas para la documentación}

\paragraph*{Compilación de LaTeX}
La memoria se ha escrito empleando el lenguaje LaTeX, que es un sistema de composición de documentos bastante usado
en el ámbito académico y científico, es necesario para poder generar la documentación final, agrupando cada capítulo, sección y
gráfica. Para generar este archivo final, se necesita ejecutar el comando \textit{all} del Makefile

\paragraph*{Corrector ortográfico gramatical}
Para comprobar activamente que lo escrito en la memoria esté correcto se ha empleado una herramienta de LaTeX llamada \href{https://github.com/sylvainhalle/textidote}{TeXtidote}.
Esta herramienta nos permite corregir la ortografía, gramática y semántica de la documentación escrita. Se puede ejecutar la corrección a través del comando \textit{check} del Makefile,
generando un borrador con la documentación marcando los errores y posibles cambios. Además, se ha añadido este comando a los hooks de GitHub para ejecutarlo antes de cada commit.

\subsection{Código}

\subsubsection*{Lenguaje de Programación}
Para el desarrollo de un proyecto es esencial decidir con qué herramienta principal, en este caso el lenguaje se va a crear. De entre mi pila de lenguajes de programación he
escogido Ruby, ya que, lo conozco con anterioridad, he trabajado con él, por lo que tengo más experiencia comparada con otras alternativas como Python o Java.
Tiene una gran simplicidad sintáctica, lo que facilita la escritura de código limpio y legible ayudando al desarrollo ágil del producto.
Cuenta con una gran batería de librerías o gemas que agiliza el desarrollo y permite la implementación rápida de características.

\subsubsection*{Integración Continua}
La integración continua es una práctica de desarrollo de software que tiene como objetivo principal mejorar la calidad del código, aumentar la eficiencia y agilizar el proceso de entrega de software.
Las diferentes opciones que encontramos para el cliente o local pueden ser git, SVN, Mercurial y para el servidor donde se harán las pruebas y la integración se presentan las siguientes
alternativas Jenkins, Travis, Circle, GitHub Actions. He decido escoger git para el cliente y GitHub Actios para el servidor porque me resultan fáciles de configurar y escalabilidad.
Gracias a esta metodología podemos automatizar la ejecución de test, linter y corrector ortográfico, de esta manera comprobaremos antes de ciertas acciones con los hooks de GitHub que todo está
correctamente. También se había sopesado la opción de utilizar una gema llamada \textit{overcommit}. Sin embargo, no se ha escogido porque sería una carga innecesaria del sistema.

\subsubsection*{Análisis estático}
Es necesario tener un constante análisis estático para mantener un código limpio, coherente y libre de errores, de esta forma garantizar la calidad, la eficiencia y sostenibilidad a largo
del tiempo. Se ha decidido elegir Rubocop, ya que es un \textit{linter} que se emplea para el lenguaje de Ruby, tiene una gran comunidad de desarrolladores, la he empleado con anterioridad
y es la más recomendada. Las otras opciones que se han barajado son Reek, Standard y Solargraph

\subsubsection*{Test unitarios e integración}


