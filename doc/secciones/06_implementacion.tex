\chapter{Implementación}

La implementación del software se ha dividido en hitos. Cada hito representa cada producto mínimamente viable que se publicará.
Los \href{https://github.com/RubenDelgadoPareja/TFG-Triage-Inteligente-Consulta-Medica/milestones}{hitos} han sido definidos en GitHub y
cada uno de ellos contiene un grupo de \href{https://github.com/RubenDelgadoPareja/TFG-Triage-Inteligente-Consulta-Medica/issues}{\textit{issues}} que se corresponden
con las distintas mejoras que se han ido incorporando al software a lo largo de su desarrollo.

A lo largo de este capítulo se pretende reflejar las herramientas usadas durante todo el proceso de desarrollo y
se argumentará por qué se han tomado estas decisiones, al igual que en el capítulo Metodología\ref{ch:metodologia} explicamos
la planificación y forma de trabajo.

\section{Hito 0: Montar repositorio inicial}\ref{sb:hito0}

\subsection{Entorno de Desarrollo Integrado}
He decidido elegir Visual Studio Code para el desarrollo del proyecto debido a una serie de ventajas. La principal ventaja
es que tengo una gran experiencia utilizándola y me siento cómodo desarrollando. Además, tiene una amplia comunidad y
extensiones que mejoran la experiencia de desarrollo y permite adaptar el IDE al proyecto, también es gratuita frente
a otras opciones, es ligero, multiplataforma y muy personalizable.

\subsection{Herramientas para la documentación}

\paragraph*{Compilación de LaTeX}
La memoria se ha escrito empleando el lenguaje LaTeX, que es un sistema de composición de documentos bastante usado
en el ámbito académico y científico, es necesario para poder generar la documentación final, agrupando cada capítulo, sección y
gráfica. Para generar este archivo final, se necesita ejecutar el comando \textit{all} del Makefile

\paragraph*{Corrector ortográfico gramatical}
Para comprobar activamente que lo escrito en la memoria esté correcto se ha empleado una herramienta de LaTeX llamada \href{https://github.com/sylvainhalle/textidote}{TeXtidote}.
Esta herramienta nos permite corregir la ortografía, gramática y semántica de la documentación escrita. Se puede ejecutar la corrección a través del comando \textit{check} del Makefile,
generando un borrador con la documentación marcando los errores y posibles cambios. Además, se ha añadido este comando a los hooks de GitHub para ejecutarlo antes de cada commit.

\subsection{Código}

\subsubsection*{Integración Continua}
La integración continua es una práctica de desarrollo de software que tiene como objetivo principal mejorar la calidad del código, aumentar la eficiencia y agilizar el proceso de entrega de software.
Las diferentes opciones que encontramos para el cliente o local pueden ser git, SVN, Mercurial y para el servidor donde se harán las pruebas y la integración se presentan las siguientes
alternativas Jenkins, Travis, Circle, GitHub Actions. He decido escoger git para el cliente y GitHub Actios para el servidor porque me resultan fáciles de configurar y escalabilidad.
Gracias a esta metodología podemos automatizar la ejecución de test, linter y corrector ortográfico, de esta manera comprobaremos antes de ciertas acciones con los hooks de GitHub que todo está
correctamente. También se había sopesado la opción de utilizar una gema llamada \textit{overcommit}. Sin embargo, no se ha escogido porque sería una carga innecesaria del sistema.


\subsubsection*{Lenguaje de Programación}
Para el desarrollo de un proyecto es esencial decidir con qué herramienta principal, en este caso el lenguaje se va a crear. De entre mi pila de lenguajes de programación he
escogido Typescript junto con Node.js, ya que, estoy trabajando con él. Creo que da una gran robustez gracias al tipado y apoya mucho al Diseño Dirigido al Dominio, no como otros lenguajes como Java o Ruby
Cuenta con una gran batería de librerías que agiliza el desarrollo y permite la implementación rápida de características.


\subsubsection*{Análisis estático}
Es necesario tener un constante análisis estático para mantener un código limpio, coherente y libre de errores, de esta forma garantizar la calidad, la eficiencia y sostenibilidad a largo
del tiempo. Se ha decidido elegir ESLint con Typescript, ya que es un \textit{linter} que se emplea para el lenguaje de JavaScript pero se puede aprovechar con TypeScript.
ESLint te permite aplicar reglas personalizadas, reglas predefinidas y configuraciones de estilo para garantizar que tu código sea consistente y libre de problemas.
No se ha escogido TSLint ya que está obsoleta y no tiene mantenimiento, también se ha barajado SonarQube y CodeClimate.

\subsubsection*{Test unitarios e integración}
